---
/**
 * Décrit un item du carrousel.
 * - src/alt : image
 * - title/subTitle/description : texte affiché sous les images (lié à l’item actif)
 * - href : lien ouvert quand l’item actif (au centre) est cliqué
 */
export type carrouselItem = {
  src: string;
  alt?: string;
  title: string;
  subTitle?: string;
  description?: string;
  href: string;
};

/**
 * Props du composant.
 * - items : liste d’items à afficher
 * - initialIndex : index de départ (par défaut 0)
 */
type Props = {
  items: carrouselItem[];
  initialIndex?: number;
};

const { items, initialIndex = 0 } = Astro.props;

/**
 * Petit garde-fou : on évite d’afficher un carrousel vide (sinon le JS/CSS n’a pas de sens).
 */
if (!items?.length) {
  throw new Error(
    "[Carrousel] La prop `items` est requise et doit contenir au moins 1 élément."
  );
}
---

<!--
  Conteneur racine du carrousel.
  data-items : on sérialise les items en JSON pour que le script inline puisse les lire côté client.
  data-initial-index : index de départ côté JS.
  tabindex="0" : permet de donner le focus au carrousel (utile pour l’accessibilité / focus-visible).
-->
<div
  class="carrousel"
  data-carrousel
  data-items={JSON.stringify(items)}
  data-initial-index={String(initialIndex)}
  role="region"
  aria-label="Carrousel"
  tabindex="0"
>
  <!--
    Zone d’affichage des 3 images (prev / active / next).
    Les slides sont positionnées en absolute, donc elles se chevauchent.
  -->
  <div class="carrousel__viewport" aria-live="polite">
    <!-- Bouton "Précédent": le script cherche [data-prev] et décrémente l’index -->
    <button
      class="carrousel__btn carrousel__btn--prev"
      type="button"
      data-prev
      aria-label="Précédent"
    >
      ‹
    </button>

    <!-- Bouton "Suivant": le script cherche [data-next] et incrémente l’index -->
    <button
      class="carrousel__btn carrousel__btn--next"
      type="button"
      data-next
      aria-label="Suivant"
    >
      ›
    </button>

    <!--
      Chaque item est un <a> (slide) : si la slide est ACTIVE, cliquer navigue vers href.
      Si la slide est PREV/NEXT, on intercepte le clic pour la rendre active (voir JS).
    -->
    {
      items.map((it, i) => (
        <a
          class="carrousel__slide"
          href={it.href}
          data-slide
          data-index={i}
          aria-label={it.title}
        >
          <img
            class="carrousel__img"
            src={it.src}
            alt={it.alt ?? it.title}
            loading="lazy"
            draggable="false"
          />
        </a>
      ))
    }
  </div>

  <!--
    Texte associé à l’item actif (titre / sous-titre / description).
    Le script met à jour ces éléments via data-title / data-subtitle / data-desc.
  -->
  <div class="carrousel__meta">
    <h3 class="carrousel__title" data-title></h3>
    <p class="carrousel__subtitle" data-subtitle></p>
    <p class="carrousel__desc" data-desc></p>
  </div>
</div>

<style>
  .carrousel {
    width: 100%;
    height: 100%; /* remplit la colonne droite de ta PreviewSection */

    user-select: none; /* évite de sélectionner du texte en cliquant/glissant */
    outline: none;

    /* Layout vertical : viewport (images) + meta (texte) */
    display: flex;
    flex-direction: column;
    justify-content: center; /* centre verticalement dans la zone droite */
    gap: 0.75rem;
  }

  .carrousel__viewport {
    position: relative; /* nécessaire pour positionner boutons/slides en absolute */
    height: 100%; /* taille FIXE comme demandé */
    width: 100%;
    overflow: hidden; /* masque les débordements des images */
  }

  /* =========================
     Boutons prev/next
     ========================= */
  .carrousel__btn {
    position: absolute;
    top: 50%;
    z-index: 10; /* IMPORTANT: au-dessus des slides (sinon invisible) */

    width: 2.25rem;
    height: 2.25rem;

    border: 1px solid rgba(255, 255, 255, 0.35);
    background: rgba(0, 0, 0, 0.35);
    color: white;

    display: grid;
    place-items: center;

    cursor: pointer;
    pointer-events: auto; /* garantit que le bouton capte bien les clics */
    transition:
      background-color 160ms ease-out,
      transform 160ms ease-out;
  }

  /* Positionnement à gauche/droite dans le viewport */
  .carrousel__btn--prev {
    left: 0.5rem;
  }
  .carrousel__btn--next {
    right: 0.5rem;
  }

  .carrousel__btn:hover {
    background: rgba(0, 0, 0, 0.55);
    transform: scale(1.05);
  }

  .carrousel__btn:focus-visible {
    outline: 2px solid rgba(255, 255, 255, 0.85);
    outline-offset: 2px;
  }

  /* ===============
     Slides (images)
     =============== */

  .carrousel__slide {
    position: absolute;
    top: 50%;
    left: 50%;

    width: 15rem; /* taille FIXE */
    height: 15rem;

    /* état par défaut : invisible + non cliquable.
       Ça évite les "clics fantômes" sur les slides cachées. */
    opacity: 0;
    pointer-events: none;
    z-index: 1;

    /* transform de base (centrée) : sera remplacée par is-active/is-prev/is-next */
    transform: translate(-50%, -50%) scale(0.9);

    transition:
      transform 220ms cubic-bezier(0, 0, 0.2, 1),
      opacity 220ms cubic-bezier(0, 0, 0.2, 1);
  }

  /* Slide active (au centre, devant) */
  .carrousel__slide.is-active {
    opacity: 1;
    z-index: 3;
    pointer-events: auto; /* cliquable (et navigue vers le href) */
    transform: translate(-50%, -50%) scale(1);
  }

  /* Slide précédente (à gauche, en retrait) */
  .carrousel__slide.is-prev {
    opacity: 0.7;
    z-index: 2;
    pointer-events: auto; /* cliquable (mais JS intercepte pour recentrer) */
    transform: translate(calc(-50% - 55%), -50%) scale(0.92);
  }

  /* Slide suivante (à droite, en retrait) */
  .carrousel__slide.is-next {
    opacity: 0.7;
    z-index: 2;
    pointer-events: auto; /* cliquable (mais JS intercepte pour recentrer) */
    transform: translate(calc(-50% + 55%), -50%) scale(0.92);
  }

  /* =========================
     Hover scale demandé (1.05)
     =========================
     On l'applique à l'IMG (et pas à la slide),
     car la slide a déjà un transform de positionnement.
     Si on mettait un hover:scale sur la slide, on écraserait/combinerait mal les transforms.
  */
  .carrousel__img {
    display: block;
    width: 95%;
    height: 95%;
    border-radius: 0.5rem;
    object-fit: cover;

    transform: scale(1);
    transition: transform 200ms cubic-bezier(0, 0, 0.2, 1);
  }

  .carrousel__slide.is-active:hover .carrousel__img,
  .carrousel__slide.is-prev:hover .carrousel__img,
  .carrousel__slide.is-next:hover .carrousel__img,
  .carrousel__slide.is-active:focus-visible .carrousel__img,
  .carrousel__slide.is-prev:focus-visible .carrousel__img,
  .carrousel__slide.is-next:focus-visible .carrousel__img {
    transform: scale(1.05);
  }

  /* Texte centré sous les images */
  .carrousel__meta {
    text-align: center;
  }

  .carrousel__title {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 700;
  }

  .carrousel__subtitle {
    margin: 0.25rem 0 0;
    opacity: 0.85;
    font-style: italic;
  }

  .carrousel__desc {
    margin: 0.5rem auto 0;
    max-width: 60ch;
    opacity: 0.9;
  }

  /* Accessibilité: si l’utilisateur préfère moins d’animations */
  @media (prefers-reduced-motion: reduce) {
    .carrousel__slide,
    .carrousel__img,
    .carrousel__btn {
      transition: none;
    }
  }
</style>

<script is:inline>
  (() => {
    /**
     * On initialise TOUS les carrousels de la page
     * (tu en as 2 dans index.astro), pas seulement le premier.
     */
    const roots = Array.from(document.querySelectorAll("[data-carrousel]"));
    if (!roots.length) return;

    /**
     * mod : permet de boucler proprement (quand on dépasse 0 ou n-1).
     * Exemple: mod(-1, 4) => 3
     */
    const mod = (n, m) => ((n % m) + m) % m;

    roots.forEach((root) => {
      // On récupère les items sérialisés dans data-items.
      const items = JSON.parse(root.getAttribute("data-items") || "[]");

      // Toutes les slides <a>
      const slides = Array.from(root.querySelectorAll("[data-slide]"));

      // Boutons prev/next
      const prevBtn = root.querySelector("[data-prev]");
      const nextBtn = root.querySelector("[data-next]");

      // Éléments texte à mettre à jour
      const titleEl = root.querySelector("[data-title]");
      const subtitleEl = root.querySelector("[data-subtitle]");
      const descEl = root.querySelector("[data-desc]");

      // Index actif courant
      let index = Number(root.getAttribute("data-initial-index") || 0) || 0;

      /**
       * render() :
       * - calcule prev/next
       * - applique les classes is-prev/is-active/is-next
       * - met à jour les textes sous le carrousel
       */
      function render() {
        const n = items.length;
        if (!n) return;

        index = mod(index, n);
        const prev = mod(index - 1, n);
        const next = mod(index + 1, n);

        slides.forEach((el, i) => {
          el.classList.remove("is-prev", "is-active", "is-next");
          if (i === index) el.classList.add("is-active");
          else if (i === prev) el.classList.add("is-prev");
          else if (i === next) el.classList.add("is-next");
        });

        const it = items[index];
        if (titleEl) titleEl.textContent = it?.title ?? "";
        if (subtitleEl) subtitleEl.textContent = it?.subTitle ?? "";
        if (descEl) descEl.textContent = it?.description ?? "";
      }

      /**
       * go(delta) :
       * delta = +1 => slide suivante
       * delta = -1 => slide précédente
       */
      function go(delta) {
        index = mod(index + delta, items.length);
        render();
      }

      /**
       * Clic sur une slide :
       * - si ce n’est PAS la slide active => on empêche la navigation et on recentre
       * - si c’est la slide active => on laisse le lien <a> naviguer normalement
       */
      slides.forEach((el, i) => {
        el.addEventListener("click", (e) => {
          if (i !== index) {
            e.preventDefault();
            index = i;
            render();
          }
        });
      });

      // Navigation via boutons
      prevBtn?.addEventListener("click", (e) => {
        e.preventDefault();
        go(-1);
      });

      nextBtn?.addEventListener("click", (e) => {
        e.preventDefault();
        go(+1);
      });

      // Premier rendu
      render();
    });
  })();
</script>
